<<<<<<< HEAD
exports.parse = exports.decode = decode

=======

exports.parse = exports.decode = decode
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
exports.stringify = exports.encode = encode

exports.safe = safe
exports.unsafe = unsafe

<<<<<<< HEAD
var eol = typeof process !== 'undefined' &&
  process.platform === 'win32' ? '\r\n' : '\n'

function encode (obj, opt) {
  var children = []
  var out = ''

  if (typeof opt === 'string') {
=======
var eol = process.platform === "win32" ? "\r\n" : "\n"

function encode (obj, opt) {
  var children = []
    , out = ""

  if (typeof opt === "string") {
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
    opt = {
      section: opt,
      whitespace: false
    }
  } else {
    opt = opt || {}
    opt.whitespace = opt.whitespace === true
  }

<<<<<<< HEAD
  var separator = opt.whitespace ? ' = ' : '='
=======
  var separator = opt.whitespace ? " = " : "="
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d

  Object.keys(obj).forEach(function (k, _, __) {
    var val = obj[k]
    if (val && Array.isArray(val)) {
<<<<<<< HEAD
      val.forEach(function (item) {
        out += safe(k + '[]') + separator + safe(item) + '\n'
      })
    } else if (val && typeof val === 'object') {
=======
        val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n"
        })
    }
    else if (val && typeof val === "object") {
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
      children.push(k)
    } else {
      out += safe(k) + separator + safe(val) + eol
    }
  })

  if (opt.section && out.length) {
<<<<<<< HEAD
    out = '[' + safe(opt.section) + ']' + eol + out
=======
    out = "[" + safe(opt.section) + "]" + eol + out
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
  }

  children.forEach(function (k, _, __) {
    var nk = dotSplit(k).join('\\.')
<<<<<<< HEAD
    var section = (opt.section ? opt.section + '.' : '') + nk
=======
    var section = (opt.section ? opt.section + "." : "") + nk
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
    var child = encode(obj[k], {
      section: section,
      whitespace: opt.whitespace
    })
    if (out.length && child.length) {
      out += eol
    }
    out += child
  })

  return out
}

function dotSplit (str) {
  return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002')
<<<<<<< HEAD
    .replace(/\\\./g, '\u0001')
    .split(/\./).map(function (part) {
      return part.replace(/\1/g, '\\.')
      .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
    })
=======
         .replace(/\\\./g, '\u0001')
         .split(/\./).map(function (part) {
           return part.replace(/\1/g, '\\.')
                  .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
        })
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
}

function decode (str) {
  var out = {}
<<<<<<< HEAD
  var p = out
  var section = null
  //          section     |key      = value
  var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i
  var lines = str.split(/[\r\n]+/g)
=======
    , p = out
    , section = null
    , state = "START"
           // section     |key = value
    , re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i
    , lines = str.split(/[\r\n]+/g)
    , section = null
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d

  lines.forEach(function (line, _, __) {
    if (!line || line.match(/^\s*[;#]/)) return
    var match = line.match(re)
    if (!match) return
    if (match[1] !== undefined) {
      section = unsafe(match[1])
      p = out[section] = out[section] || {}
      return
    }
    var key = unsafe(match[2])
<<<<<<< HEAD
    var value = match[3] ? unsafe(match[4]) : true
=======
      , value = match[3] ? unsafe((match[4] || "")) : true
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
    switch (value) {
      case 'true':
      case 'false':
      case 'null': value = JSON.parse(value)
    }

    // Convert keys with '[]' suffix to an array
<<<<<<< HEAD
    if (key.length > 2 && key.slice(-2) === '[]') {
      key = key.substring(0, key.length - 2)
      if (!p[key]) {
        p[key] = []
      } else if (!Array.isArray(p[key])) {
        p[key] = [p[key]]
      }
=======
    if (key.length > 2 && key.slice(-2) === "[]") {
        key = key.substring(0, key.length - 2)
        if (!p[key]) {
          p[key] = []
        }
        else if (!Array.isArray(p[key])) {
          p[key] = [p[key]]
        }
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
    }

    // safeguard against resetting a previously defined
    // array by accidentally forgetting the brackets
    if (Array.isArray(p[key])) {
      p[key].push(value)
<<<<<<< HEAD
    } else {
=======
    }
    else {
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
      p[key] = value
    }
  })

  // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
  // use a filter to return the keys that have to be deleted.
  Object.keys(out).filter(function (k, _, __) {
<<<<<<< HEAD
    if (!out[k] ||
      typeof out[k] !== 'object' ||
      Array.isArray(out[k])) {
      return false
    }
    // see if the parent section is also an object.
    // if so, add it to that, and mark this one for deletion
    var parts = dotSplit(k)
    var p = out
    var l = parts.pop()
    var nl = l.replace(/\\\./g, '.')
    parts.forEach(function (part, _, __) {
      if (!p[part] || typeof p[part] !== 'object') p[part] = {}
      p = p[part]
    })
    if (p === out && nl === l) {
      return false
    }
=======
    if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k])) return false
    // see if the parent section is also an object.
    // if so, add it to that, and mark this one for deletion
    var parts = dotSplit(k)
      , p = out
      , l = parts.pop()
      , nl = l.replace(/\\\./g, '.')
    parts.forEach(function (part, _, __) {
      if (!p[part] || typeof p[part] !== "object") p[part] = {}
      p = p[part]
    })
    if (p === out && nl === l) return false
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
    p[nl] = out[k]
    return true
  }).forEach(function (del, _, __) {
    delete out[del]
  })

  return out
}

function isQuoted (val) {
<<<<<<< HEAD
  return (val.charAt(0) === '"' && val.slice(-1) === '"') ||
    (val.charAt(0) === "'" && val.slice(-1) === "'")
}

function safe (val) {
  return (typeof val !== 'string' ||
    val.match(/[=\r\n]/) ||
    val.match(/^\[/) ||
    (val.length > 1 &&
     isQuoted(val)) ||
    val !== val.trim())
      ? JSON.stringify(val)
      : val.replace(/;/g, '\\;').replace(/#/g, '\\#')
}

function unsafe (val, doUnesc) {
  val = (val || '').trim()
  if (isQuoted(val)) {
    // remove the single quotes before calling JSON.parse
    if (val.charAt(0) === "'") {
      val = val.substr(1, val.length - 2)
=======
  return (val.charAt(0) === "\"" && val.slice(-1) === "\"")
         || (val.charAt(0) === "'" && val.slice(-1) === "'")
}

function safe (val) {
  return ( typeof val !== "string"
         || val.match(/[=\r\n]/)
         || val.match(/^\[/)
         || (val.length > 1
             && isQuoted(val))
         || val !== val.trim() )
         ? JSON.stringify(val)
         : val.replace(/;/g, '\\;').replace(/#/g, "\\#")
}

function unsafe (val, doUnesc) {
  val = (val || "").trim()
  if (isQuoted(val)) {
    // remove the single quotes before calling JSON.parse
    if (val.charAt(0) === "'") {
      val = val.substr(1, val.length - 2);
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
    }
    try { val = JSON.parse(val) } catch (_) {}
  } else {
    // walk the val to find the first not-escaped ; character
    var esc = false
<<<<<<< HEAD
    var unesc = ''
    for (var i = 0, l = val.length; i < l; i++) {
      var c = val.charAt(i)
      if (esc) {
        if ('\\;#'.indexOf(c) !== -1) {
          unesc += c
        } else {
          unesc += '\\' + c
        }
        esc = false
      } else if (';#'.indexOf(c) !== -1) {
        break
      } else if (c === '\\') {
=======
    var unesc = "";
    for (var i = 0, l = val.length; i < l; i++) {
      var c = val.charAt(i)
      if (esc) {
        if ("\\;#".indexOf(c) !== -1)
          unesc += c
        else
          unesc += "\\" + c
        esc = false
      } else if (";#".indexOf(c) !== -1) {
        break
      } else if (c === "\\") {
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
        esc = true
      } else {
        unesc += c
      }
    }
<<<<<<< HEAD
    if (esc) {
      unesc += '\\'
    }
    return unesc.trim()
=======
    if (esc)
      unesc += "\\"
    return unesc
>>>>>>> 45cc33bf407cd73df953efc2c1ab1b7fbf4c2d8d
  }
  return val
}
